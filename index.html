<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apple-Like Image Processing</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    canvas {
      border: 1px solid #333;
      margin: 10px;
      max-width: 100%;
    }
    button, input {
      margin: 5px;
      padding: 5px 10px;
    }
    #controls {
      margin: 20px auto;
      max-width: 500px;
      text-align: left;
    }
    #controls label {
      display: inline-block;
      width: 150px;
    }
  </style>
</head>
<body>
  <h1>Apple-Like Image Processing</h1>
  <input type="file" id="fileInput" accept="image/*">
  <button id="processButton">Process Image</button>
  <button id="downloadButton">Download Processed Image</button>

  <div id="controls">
    <div>
      <label for="sigmaDInput">Bilateral Sigma D:</label>
      <input type="range" id="sigmaDInput" min="0.1" max="5.0" step="0.1" value="1.5">
      <span id="sigmaDValue">1.5</span>
    </div>
    <div>
      <label for="sigmaCInput">Bilateral Sigma C:</label>
      <input type="range" id="sigmaCInput" min="0.01" max="1.0" step="0.01" value="0.1">
      <span id="sigmaCValue">0.1</span>
    </div>
    <div>
      <label for="unsharpInput">Unsharp Amount:</label>
      <input type="range" id="unsharpInput" min="0.5" max="3.0" step="0.1" value="1.5">
      <span id="unsharpValue">1.5</span>
    </div>
  </div>

  <div>
    <h2>Original Image</h2>
    <canvas id="canvas1"></canvas>
  </div>
  <div>
    <h2>Processed Image</h2>
    <canvas id="canvas2"></canvas>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const processButton = document.getElementById('processButton');
    const downloadButton = document.getElementById('downloadButton');
    const canvas1 = document.getElementById('canvas1');
    const canvas2 = document.getElementById('canvas2');
    const ctx1 = canvas1.getContext('2d');
    let gl, programBilateral, programBlur, programUnsharp, programColor;

    // Get controls and display elements
    const sigmaDInput = document.getElementById('sigmaDInput');
    const sigmaCInput = document.getElementById('sigmaCInput');
    const unsharpInput = document.getElementById('unsharpInput');
    const sigmaDValue = document.getElementById('sigmaDValue');
    const sigmaCValue = document.getElementById('sigmaCValue');
    const unsharpValue = document.getElementById('unsharpValue');

    // Update display values when sliders change
    sigmaDInput.addEventListener('input', () => { sigmaDValue.textContent = sigmaDInput.value; });
    sigmaCInput.addEventListener('input', () => { sigmaCValue.textContent = sigmaCInput.value; });
    unsharpInput.addEventListener('input', () => { unsharpValue.textContent = unsharpInput.value; });

    // Vertex shader source (used for all passes)
    const vertexShaderSrc = `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `;

    // Fragment shader for bilateral filter
    const bilateralFragSrc = `
      precision mediump float;
      uniform sampler2D u_texture;
      uniform vec2 u_texSize;
      uniform float u_sigmaD;
      uniform float u_sigmaC;
      varying vec2 v_texCoord;
      void main() {
        vec4 center = texture2D(u_texture, v_texCoord);
        vec4 sum = vec4(0.0);
        float totalWeight = 0.0;
        float dFactor = 1.0 / (2.0 * u_sigmaD * u_sigmaD);
        float cFactor = 1.0 / (2.0 * u_sigmaC * u_sigmaC);
        for (int i = -2; i <= 2; i++) {
          for (int j = -2; j <= 2; j++) {
            vec2 offset = vec2(float(i), float(j)) / u_texSize;
            vec4 neighbor = texture2D(u_texture, v_texCoord + offset);
            float d = float(i * i + j * j);
            vec3 colorDiff = center.rgb - neighbor.rgb;
            float c = dot(colorDiff, colorDiff);
            float weight = exp(-d * dFactor) * exp(-c * cFactor);
            sum += neighbor * weight;
            totalWeight += weight;
          }
        }
        gl_FragColor = sum / totalWeight;
      }
    `;

    // Fragment shader for Gaussian blur
    const blurFragSrc = `
      precision mediump float;
      uniform sampler2D u_texture;
      uniform vec2 u_texSize;
      varying vec2 v_texCoord;
      void main() {
        vec4 sum = vec4(0.0);
        float totalWeight = 0.0;
        float sigma = 1.0;
        float dFactor = 1.0 / (2.0 * sigma * sigma);
        for (int i = -2; i <= 2; i++) {
          for (int j = -2; j <= 2; j++) {
            vec2 offset = vec2(float(i), float(j)) / u_texSize;
            float d = float(i * i + j * j);
            float weight = exp(-d * dFactor);
            sum += texture2D(u_texture, v_texCoord + offset) * weight;
            totalWeight += weight;
          }
        }
        gl_FragColor = sum / totalWeight;
      }
    `;

    // Fragment shader for unsharp mask
    const unsharpFragSrc = `
      precision mediump float;
      uniform sampler2D u_original; // Bilateral filtered
      uniform sampler2D u_blurred;  // Blurred version
      uniform float u_amount;
      varying vec2 v_texCoord;
      void main() {
        vec4 orig = texture2D(u_original, v_texCoord);
        vec4 blur = texture2D(u_blurred, v_texCoord);
        gl_FragColor = orig + u_amount * (orig - blur);
      }
    `;

    // Fragment shader for color correction
    const colorFragSrc = `
      precision mediump float;
      uniform sampler2D u_texture;
      uniform vec3 u_minVal;
      uniform vec3 u_maxVal;
      varying vec2 v_texCoord;
      void main() {
        vec4 color = texture2D(u_texture, v_texCoord);
        vec3 corrected = clamp((color.rgb - u_minVal) / (u_maxVal - u_minVal), 0.0, 1.0);
        gl_FragColor = vec4(corrected, color.a);
      }
    `;

    // Load image
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          canvas1.width = img.width;
          canvas1.height = img.height;
          ctx1.drawImage(img, 0, 0);
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Process image
    processButton.addEventListener('click', () => {
      const imageData = ctx1.getImageData(0, 0, canvas1.width, canvas1.height);
      if (!imageData) return;

      // Compute histogram-based min/max for color correction
      const { min, max } = computeMinMax(imageData);

      // Initialize WebGL
      gl = canvas2.getContext('webgl');
      if (!gl) {
        alert('WebGL not supported');
        return;
      }
      canvas2.width = imageData.width;
      canvas2.height = imageData.height;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

      // Compile shaders
      programBilateral = createProgram(vertexShaderSrc, bilateralFragSrc);
      programBlur = createProgram(vertexShaderSrc, blurFragSrc);
      programUnsharp = createProgram(vertexShaderSrc, unsharpFragSrc);
      programColor = createProgram(vertexShaderSrc, colorFragSrc);

      // Set up quad
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,  0, 0,
         1, -1,  1, 0,
        -1,  1,  0, 1,
        -1,  1,  0, 1,
         1, -1,  1, 0,
         1,  1,  1, 1
      ]), gl.STATIC_DRAW);

      // Create textures
      const texA = createTexture(imageData.width, imageData.height);
      const texB = createTexture(imageData.width, imageData.height);
      gl.bindTexture(gl.TEXTURE_2D, texA);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas1);

      // Create framebuffers
      const fbA = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbA);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texA, 0);

      const fbB = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbB);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texB, 0);

      // Processing pipeline
      const texSize = [imageData.width, imageData.height];

      // Step 1: Bilateral filter (texA -> texB)
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbB);
      gl.useProgram(programBilateral);
      setupAttributes(programBilateral, positionBuffer);
      gl.uniform1i(gl.getUniformLocation(programBilateral, 'u_texture'), 0);
      gl.uniform2fv(gl.getUniformLocation(programBilateral, 'u_texSize'), texSize);
      // Use slider values for bilateral filter parameters
      gl.uniform1f(gl.getUniformLocation(programBilateral, 'u_sigmaD'), parseFloat(sigmaDInput.value));
      gl.uniform1f(gl.getUniformLocation(programBilateral, 'u_sigmaC'), parseFloat(sigmaCInput.value));
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Step 2: Gaussian blur (texB -> texA)
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbA);
      gl.useProgram(programBlur);
      setupAttributes(programBlur, positionBuffer);
      gl.uniform1i(gl.getUniformLocation(programBlur, 'u_texture'), 0);
      gl.uniform2fv(gl.getUniformLocation(programBlur, 'u_texSize'), texSize);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Step 3: Unsharp mask (texB and texA -> texB)
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbB);
      gl.useProgram(programUnsharp);
      setupAttributes(programUnsharp, positionBuffer);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texB);
      gl.uniform1i(gl.getUniformLocation(programUnsharp, 'u_original'), 0);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, texA);
      gl.uniform1i(gl.getUniformLocation(programUnsharp, 'u_blurred'), 1);
      gl.uniform1f(gl.getUniformLocation(programUnsharp, 'u_amount'), parseFloat(unsharpInput.value));
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Step 4: Color correction (texB -> texA)
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbA);
      gl.useProgram(programColor);
      setupAttributes(programColor, positionBuffer);
      gl.uniform1i(gl.getUniformLocation(programColor, 'u_texture'), 0);
      gl.uniform3fv(gl.getUniformLocation(programColor, 'u_minVal'), min);
      gl.uniform3fv(gl.getUniformLocation(programColor, 'u_maxVal'), max);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Final render to canvas
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.useProgram(programColor); // Reuse color program for simplicity
      setupAttributes(programColor, positionBuffer);
      gl.uniform1i(gl.getUniformLocation(programColor, 'u_texture'), 0);
      gl.uniform3fv(gl.getUniformLocation(programColor, 'u_minVal'), [0, 0, 0]);
      gl.uniform3fv(gl.getUniformLocation(programColor, 'u_maxVal'), [1, 1, 1]);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    });

    // Download the processed image
    downloadButton.addEventListener('click', () => {
      const dataURL = canvas2.toDataURL('image/png');
      const link = document.createElement('a');
      link.download = 'processed-image.png';
      link.href = dataURL;
      link.click();
    });

    // Helper functions
    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(vertexSrc, fragmentSrc) {
      const vs = createShader(gl.VERTEX_SHADER, vertexSrc);
      const fs = createShader(gl.FRAGMENT_SHADER, fragmentSrc);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    function createTexture(width, height) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      return texture;
    }

    function setupAttributes(program, buffer) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      const posLoc = gl.getAttribLocation(program, 'a_position');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
      const texLoc = gl.getAttribLocation(program, 'a_texCoord');
      gl.enableVertexAttribArray(texLoc);
      gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 16, 8);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }

    function computeMinMax(imageData) {
      const data = imageData.data;
      const hist = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      for (let i = 0; i < data.length; i += 4) {
        hist[0][data[i]]++;
        hist[1][data[i + 1]]++;
        hist[2][data[i + 2]]++;
      }
      const total = imageData.width * imageData.height;
      const thresholdLow = total * 0.005;
      const thresholdHigh = total * 0.995;
      const min = [0, 0, 0];
      const max = [255, 255, 255];
      for (let c = 0; c < 3; c++) {
        let cumsum = 0;
        for (let i = 0; i < 256; i++) {
          cumsum += hist[c][i];
          if (cumsum >= thresholdLow && min[c] === 0) min[c] = i;
          if (cumsum >= thresholdHigh) {
            max[c] = i;
            break;
          }
        }
      }
      return { min: min.map(v => v / 255), max: max.map(v => v / 255) };
    }
  </script>
</body>
</html>
