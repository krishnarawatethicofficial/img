<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Existing HTML head content unchanged -->
</head>
<body>
  <!-- Existing HTML body content unchanged -->
  <script>
    // Constants
    const DEFAULTS = {
      SIGMA_D: 1.5,
      SIGMA_C: 0.1,
      UNSHARP_AMOUNT: 1.5,
      BLUR_SIGMA: 1.0,
      GAMMA: 1.0,
      MAX_PREVIEW_SIZE: 1024
    };

    // Shader sources
    const SHADERS = {
      vertex: `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_texCoord;
        }
      `,
      bilateral: `
        precision mediump float;
        uniform sampler2D u_texture;
        uniform vec2 u_texSize;
        uniform float u_sigmaD;
        uniform float u_sigmaC;
        varying vec2 v_texCoord;
        void main() {
          // Bilateral filter implementation
          vec4 center = texture2D(u_texture, v_texCoord);
          vec4 sum = vec4(0.0);
          float totalWeight = 0.0;
          float dFactor = 1.0 / (2.0 * u_sigmaD * u_sigmaD);
          float cFactor = 1.0 / (2.0 * u_sigmaC * u_sigmaC);
          for (int i = -2; i <= 2; i++) {
            for (int j = -2; j <= 2; j++) {
              vec2 offset = vec2(float(i), float(j)) / u_texSize;
              vec4 neighbor = texture2D(u_texture, v_texCoord + offset);
              float d = float(i * i + j * j);
              vec3 colorDiff = center.rgb - neighbor.rgb;
              float c = dot(colorDiff, colorDiff);
              float weight = exp(-d * dFactor) * exp(-c * cFactor);
              sum += neighbor * weight;
              totalWeight += weight;
            }
          }
          gl_FragColor = sum / totalWeight;
        }
      `,
      blur: `
        precision mediump float;
        uniform sampler2D u_texture;
        uniform vec2 u_texSize;
        uniform float u_sigma;
        varying vec2 v_texCoord;
        void main() {
          // Gaussian blur (configurable direction)
          vec4 sum = vec4(0.0);
          float totalWeight = 0.0;
          float dFactor = 1.0 / (2.0 * u_sigma * u_sigma);
          for (int i = -2; i <= 2; i++) {
            vec2 offset = vec2(float(i), 0.0) / u_texSize; // Horizontal by default
            float d = float(i * i);
            float weight = exp(-d * dFactor);
            sum += texture2D(u_texture, v_texCoord + offset) * weight;
            totalWeight += weight;
          }
          gl_FragColor = sum / totalWeight;
        }
      `,
      unsharp: `
        precision mediump float;
        uniform sampler2D u_original;
        uniform sampler2D u_blurred;
        uniform float u_amount;
        varying vec2 v_texCoord;
        void main() {
          vec4 orig = texture2D(u_original, v_texCoord);
          vec4 blur = texture2D(u_blurred, v_texCoord);
          gl_FragColor = clamp(orig + u_amount * (orig - blur), 0.0, 1.0);
        }
      `,
      color: `
        precision mediump float;
        uniform sampler2D u_texture;
        uniform vec3 u_minVal;
        uniform vec3 u_maxVal;
        uniform float u_gamma;
        varying vec2 v_texCoord;
        void main() {
          vec4 color = texture2D(u_texture, v_texCoord);
          vec3 corrected = clamp((color.rgb - u_minVal) / (u_maxVal - u_minVal), 0.0, 1.0);
          corrected = pow(corrected, vec3(1.0 / u_gamma));
          gl_FragColor = vec4(corrected, color.a);
        }
      `,
      compare: `
        precision mediump float;
        uniform sampler2D u_original;
        uniform sampler2D u_processed;
        uniform float u_split;
        varying vec2 v_texCoord;
        void main() {
          gl_FragColor = v_texCoord.x < u_split ? texture2D(u_original, v_texCoord) : texture2D(u_processed, v_texCoord);
        }
      `
    };

    // DOM Elements
    const DOM = {
      fileInput: document.getElementById('fileInput'),
      processButton: document.getElementById('processButton'),
      downloadButton: document.getElementById('downloadButton'),
      resetButton: document.getElementById('resetButton'),
      realtimeCheckbox: document.getElementById('realtimeCheckbox'),
      canvas1: document.getElementById('canvas1'),
      canvas2: document.getElementById('canvas2'),
      loading: document.getElementById('loading'),
      compareSlider: document.getElementById('compareSlider'),
      controls: {
        sigmaD: { input: document.getElementById('sigmaDInput'), value: document.getElementById('sigmaDValue') },
        sigmaC: { input: document.getElementById('sigmaCInput'), value: document.getElementById('sigmaCValue') },
        unsharp: { input: document.getElementById('unsharpInput'), value: document.getElementById('unsharpValue') },
        blurSigma: { input: document.getElementById('blurSigmaInput'), value: document.getElementById('blurSigmaValue') },
        gamma: { input: document.getElementById('gammaInput'), value: document.getElementById('gammaValue') }
      }
    };

    // State
    let originalImage = null;
    let processingTimeout = null;
    let glContext = null;
    let shaderPrograms = {};
    let textures = {};
    let framebuffers = {};

    // Initialize UI
    function initUI() {
      Object.values(DOM.controls).forEach(({ input, value }) => {
        input.addEventListener('input', () => {
          value.textContent = input.value;
          if (DOM.realtimeCheckbox.checked && originalImage) debounceProcess();
        });
      });

      DOM.resetButton.addEventListener('click', resetParameters);
      DOM.fileInput.addEventListener('change', loadImage);
      DOM.processButton.addEventListener('click', () => originalImage && processImage());
      DOM.downloadButton.addEventListener('click', downloadImage);
    }

    function resetParameters() {
      DOM.controls.sigmaD.input.value = DEFAULTS.SIGMA_D;
      DOM.controls.sigmaC.input.value = DEFAULTS.SIGMA_C;
      DOM.controls.unsharp.input.value = DEFAULTS.UNSHARP_AMOUNT;
      DOM.controls.blurSigma.input.value = DEFAULTS.BLUR_SIGMA;
      DOM.controls.gamma.input.value = DEFAULTS.GAMMA;
      updateControlValues();
      if (originalImage) processImage();
    }

    function updateControlValues() {
      Object.values(DOM.controls).forEach(({ input, value }) => value.textContent = input.value);
    }

    // Image Loading
    function loadImage(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          const { width, height } = scaleDimensions(img.width, img.height, DEFAULTS.MAX_PREVIEW_SIZE);
          DOM.canvas1.width = width;
          DOM.canvas1.height = height;
          DOM.canvas1.getContext('2d').drawImage(img, 0, 0, width, height);
          originalImage = img;
          processImage();
          DOM.downloadButton.classList.remove('disabled');
          DOM.compareSlider.style.display = 'block';
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }

    // WebGL Initialization
    function initWebGL() {
      glContext = DOM.canvas2.getContext('webgl', { preserveDrawingBuffer: true });
      if (!glContext) throw new Error('WebGL not supported');

      DOM.canvas2.width = DOM.canvas1.width;
      DOM.canvas2.height = DOM.canvas1.height;
      glContext.viewport(0, 0, glContext.drawingBufferWidth, glContext.drawingBufferHeight);

      // Compile shaders
      shaderPrograms = {
        bilateral: createProgram(SHADERS.vertex, SHADERS.bilateral),
        blurH: createProgram(SHADERS.vertex, SHADERS.blur),
        blurV: createProgram(SHADERS.vertex, SHADERS.blur.replace('vec2(float(i), 0.0)', 'vec2(0.0, float(i))')),
        unsharp: createProgram(SHADERS.vertex, SHADERS.unsharp),
        color: createProgram(SHADERS.vertex, SHADERS.color),
        compare: createProgram(SHADERS.vertex, SHADERS.compare)
      };

      // Setup quad
      createQuadBuffer();
      initTexturesAndFramebuffers();
    }

    function initTexturesAndFramebuffers() {
      const width = DOM.canvas2.width;
      const height = DOM.canvas2.height;
      textures = {
        original: createTexture(width, height),
        temp1: createTexture(width, height),
        temp2: createTexture(width, height),
        processed: createTexture(width, height)
      };
      glContext.bindTexture(glContext.TEXTURE_2D, textures.original);
      glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, glContext.RGBA, glContext.UNSIGNED_BYTE, DOM.canvas1);

      framebuffers = {
        temp1: createFramebuffer(textures.temp1),
        temp2: createFramebuffer(textures.temp2),
        processed: createFramebuffer(textures.processed)
      };
    }

    // Image Processing
    function processImage() {
      if (!originalImage) {
        alert('Please upload an image first.');
        return;
      }

      DOM.loading.style.display = 'block';
      try {
        const imageData = DOM.canvas1.getContext('2d', { willReadFrequently: true }).getImageData(0, 0, DOM.canvas1.width, DOM.canvas1.height);
        const { min, max } = computeMinMax(imageData);

        initWebGL();
        const texSize = [imageData.width, imageData.height];

        // Processing pipeline
        renderPass(shaderPrograms.bilateral, textures.original, framebuffers.temp1, {
          u_texSize: texSize,
          u_sigmaD: parseFloat(DOM.controls.sigmaD.input.value),
          u_sigmaC: parseFloat(DOM.controls.sigmaC.input.value)
        });

        renderPass(shaderPrograms.blurH, textures.temp1, framebuffers.temp2, {
          u_texSize: texSize,
          u_sigma: parseFloat(DOM.controls.blurSigma.input.value)
        });

        renderPass(shaderPrograms.blurV, textures.temp2, framebuffers.temp1, {
          u_texSize: texSize,
          u_sigma: parseFloat(DOM.controls.blurSigma.input.value)
        });

        renderPass(shaderPrograms.unsharp, null, framebuffers.temp2, {
          u_original: textures.temp1,
          u_blurred: textures.temp1,
          u_amount: parseFloat(DOM.controls.unsharp.input.value)
        }, [0, 1]);

        renderPass(shaderPrograms.color, textures.temp2, framebuffers.processed, {
          u_minVal: min,
          u_maxVal: max,
          u_gamma: parseFloat(DOM.controls.gamma.input.value)
        });

        DOM.compareSlider.oninput = renderComparison;
        renderComparison();
      } catch (error) {
        alert(`Processing failed: ${error.message}`);
        console.error(error);
      } finally {
        DOM.loading.style.display = 'none';
      }
    }

    function renderComparison() {
      glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
      glContext.useProgram(shaderPrograms.compare);
      setupAttributes(shaderPrograms.compare);
      glContext.activeTexture(glContext.TEXTURE0);
      glContext.bindTexture(glContext.TEXTURE_2D, textures.original);
      glContext.uniform1i(glContext.getUniformLocation(shaderPrograms.compare, 'u_original'), 0);
      glContext.activeTexture(glContext.TEXTURE1);
      glContext.bindTexture(glContext.TEXTURE_2D, textures.processed);
      glContext.uniform1i(glContext.getUniformLocation(shaderPrograms.compare, 'u_processed'), 1);
      glContext.uniform1f(glContext.getUniformLocation(shaderPrograms.compare, 'u_split'), DOM.compareSlider.value / 100);
      glContext.drawArrays(glContext.TRIANGLES, 0, 6);
    }

    function debounceProcess() {
      clearTimeout(processingTimeout);
      processingTimeout = setTimeout(processImage, 300);
    }

    function downloadImage() {
      const dataURL = DOM.canvas2.toDataURL('image/png');
      const link = document.createElement('a');
      link.download = 'processed-image.png';
      link.href = dataURL;
      link.click();
    }

    // WebGL Helpers
    function createShader(type, source) {
      const shader = glContext.createShader(type);
      glContext.shaderSource(shader, source);
      glContext.compileShader(shader);
      if (!glContext.getShaderParameter(shader, glContext.COMPILE_STATUS)) {
        throw new Error(`Shader compilation failed: ${glContext.getShaderInfoLog(shader)}`);
      }
      return shader;
    }

    function createProgram(vertexSrc, fragmentSrc) {
      const vs = createShader(glContext.VERTEX_SHADER, vertexSrc);
      const fs = createShader(glContext.FRAGMENT_SHADER, fragmentSrc);
      const program = glContext.createProgram();
      glContext.attachShader(program, vs);
      glContext.attachShader(program, fs);
      glContext.linkProgram(program);
      if (!glContext.getProgramParameter(program, glContext.LINK_STATUS)) {
        throw new Error(`Program linking failed: ${glContext.getProgramInfoLog(program)}`);
      }
      return program;
    }

    function createTexture(width, height) {
      const texture = glContext.createTexture();
      glContext.bindTexture(glContext.TEXTURE_2D, texture);
      glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, width, height, 0, glContext.RGBA, glContext.UNSIGNED_BYTE, null);
      glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.LINEAR);
      glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_S, glContext.CLAMP_TO_EDGE);
      glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_T, glContext.CLAMP_TO_EDGE);
      return texture;
    }

    function createFramebuffer(texture) {
      const fb = glContext.createFramebuffer();
      glContext.bindFramebuffer(glContext.FRAMEBUFFER, fb);
      glContext.framebufferTexture2D(glContext.FRAMEBUFFER, glContext.COLOR_ATTACHMENT0, glContext.TEXTURE_2D, texture, 0);
      return fb;
    }

    function createQuadBuffer() {
      const buffer = glContext.createBuffer();
      glContext.bindBuffer(glContext.ARRAY_BUFFER, buffer);
      glContext.bufferData(glContext.ARRAY_BUFFER, new Float32Array([
        -1, -1, 0, 0,
         1, -1, 1, 0,
        -1,  1, 0, 1,
        -1,  1, 0, 1,
         1, -1, 1, 0,
         1,  1, 1, 1
      ]), glContext.STATIC_DRAW);
      return buffer;
    }

    function setupAttributes(program) {
      const posLoc = glContext.getAttribLocation(program, 'a_position');
      glContext.enableVertexAttribArray(posLoc);
      glContext.vertexAttribPointer(posLoc, 2, glContext.FLOAT, false, 16, 0);
      const texLoc = glContext.getAttribLocation(program, 'a_texCoord');
      glContext.enableVertexAttribArray(texLoc);
      glContext.vertexAttribPointer(texLoc, 2, glContext.FLOAT, false, 16, 8);
    }

    function renderPass(program, inputTexture, framebuffer, uniforms, textureUnits = [0]) {
      glContext.bindFramebuffer(glContext.FRAMEBUFFER, framebuffer);
      glContext.useProgram(program);
      setupAttributes(program);

      textureUnits.forEach((unit, idx) => {
        glContext.activeTexture(glContext.TEXTURE0 + unit);
        glContext.bindTexture(glContext.TEXTURE_2D, inputTexture && idx === 0 ? inputTexture : Object.values(uniforms)[idx]);
        glContext.uniform1i(glContext.getUniformLocation(program, Object.keys(uniforms)[idx]), unit);
      });

      Object.entries(uniforms).forEach(([name, value]) => {
        const loc = glContext.getUniformLocation(program, name);
        if (name === 'u_texSize') glContext.uniform2fv(loc, value);
        else if (name === 'u_minVal' || name === 'u_maxVal') glContext.uniform3fv(loc, value);
        else if (!name.match(/u_(original|blurred|texture)/)) glContext.uniform1f(loc, value);
      });

      glContext.drawArrays(glContext.TRIANGLES, 0, 6);
    }

    // Utility Functions
    function computeMinMax(imageData) {
      const data = imageData.data;
      const hist = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      for (let i = 0; i < data.length; i += 4) {
        hist[0][data[i]]++;
        hist[1][data[i + 1]]++;
        hist[2][data[i + 2]]++;
      }
      const total = imageData.width * imageData.height;
      const thresholdLow = total * 0.005;
      const thresholdHigh = total * 0.995;
      const min = [0, 0, 0];
      const max = [255, 255, 255];
      for (let c = 0; c < 3; c++) {
        let cumsum = 0;
        for (let i = 0; i < 256; i++) {
          cumsum += hist[c][i];
          if (cumsum >= thresholdLow && min[c] === 0) min[c] = i;
          if (cumsum >= thresholdHigh) {
            max[c] = i;
            break;
          }
        }
      }
      return { min: min.map(v => v / 255), max: max.map(v => v / 255) };
    }

    function scaleDimensions(width, height, maxSize) {
      if (width <= maxSize && height <= maxSize) return { width, height };
      const aspect = width / height;
      return width > height
        ? { width: maxSize, height: Math.round(maxSize / aspect) }
        : { width: Math.round(maxSize * aspect), height: maxSize };
    }

    // Start application
    initUI();
  </script>
</body>
</html>
